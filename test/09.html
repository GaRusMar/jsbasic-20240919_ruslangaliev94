<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8"/>
    <title>Промиссы</title>
</head>
<body>

<script>

    //функции которая загружает данные для игры

    function loadData(callback) { //    callback - общепринятое название
        setTimeout(() => {
            console.log('Данные загрузились');
            // callback(); //вызвали callback
            loadImages(callback) // сразу после загрузки данных вызовем сразу загрзуку картинок и пробросим наш callback дальше
        }, 500);
    }

    function loadImages(callback) { // тут тоже будем вызывать callback в качестве аргумента
        setTimeout(() => {
            console.log('Картинки загрузились');
            loadSounds(callback);
        }, 1000)
    }

    function loadSounds(callback) {
        setTimeout(() => {
            console.log('Звуки загрузились')
            callback(); //проделала долгий путь и только тут вызвалась, но если было много данных, то сложно. Даже есть callback hell ад из колбеков
        }, 1500)
    }

    //основая функция которая должна вызываться после того как все остальные функции загрузились
    function startGame(callback) {
        console.log('Игра началась')
    }

    //до промиосв решшали такие задачи с помощью callback функций, например есть бибилотека асинк
    // loadData(startGame) //startGame прошла через две функции loadData и loadImages


    // Сейчас проблема, что каждая загрузка данных, ждем предыдущей загрузки данных из за колбеков, лучше выполнить эти функции параллельно поэтому перепием на промисы
    // надо уяснить, потмоу что в совремнном JS все крутится вокруг промисов

</script>

<script>
    // Промис - это специлаьный объект в JS у которого есть какое то внутренее состояние, в котром он гаходится
    // есть три состояния(напиши какие). Есть и методы которые повзоляют по цепочке передевать упарвление следущем функциям

    let pr = new Promise((resolve) => { //в промис передаем функцию. Функция в качевте аргумента принимает другую функцию например resolve - это просто аргумент который ссылается на функцию
        //можно писать любой асинхроный код

        setTimeout(() => {
            console.log('Асинхронный код 1');
            resolve(); //сигнал промису, что асинхроный код завершился
        }, 1000);
    })
    //по анлогии с fetch, fetch возваращет промис поэтмоу у нее так же есть метод then
    // в then мы можем предать функцию
    pr
        // эти функции then являются простыми и синхронными
        .then(() => {
            // console.log('Код 2') // это получится только когда у pr будет состояние  resolve(); //сигнал промису, что асинхроный код завершился

            //цепочка немного сломается, потому что then не знает что внутри него есть асинхроный код, но мы можем сказать then чтобы он ждал
            // setTimeout(() => {
            //     console.log('Код 2');
            // }, 500);

            //поэтмоу пишем promise
            return new Promise(resolve => {
                setTimeout(() => {
                    console.log('Код 2');
                    resolve() //важное условие! что мы закончили!
                }, 500);
            })


        })
        .then(() => {
            console.log('Код 3')
        })
    console.log(pr)
</script>

</body>
</html>

29:27
